suppressPackageStartupMessages(require("forecast"))
suppressPackageStartupMessages(require("polynom"))

# file_path <- "C:/Users/VID/Desktop/GitHub/python-darima/data/CT_test.csv"
# data <- read.csv(file_path)
#
# train_data <- ts(data[["demand"]][0:100], frequency = 24)
# test_data <- ts(data[["demand"]][2001:2300], frequency = 24)
# time <- data$time[2001:2300]


ar_coefficients <- function(ar = 0, d = 0L, ma = 0, 
                            sar = 0, D = 0L, sma = 0, 
                            mean = 0, drift = 0, 
                            m = 1L, tol = 500L) {
    mu <- mean
    dft <- drift

    # non-seasonal AR
    ar <- polynomial(c(1, -ar)) * polynomial(c(1, -1))^d

    # seasonal AR
    if (m > 1) {
        P <- length(sar)
        seasonal_poly <- numeric(m * P)
        seasonal_poly[m * seq(P)] <- sar
        sar <- polynomial(c(1, -seasonal_poly)) * polynomial(c(1, rep(0, m - 1), -1))^D
    }
    else {
        sar <- 1
    }

    # non-seasonal MA
    ma <- polynomial(c(1, ma))

    # seasonal MA
    if (m > 1) {
        Q <- length(sma)
        seasonal_poly <- numeric(m * Q)
        seasonal_poly[m * seq(Q)] <- sma
        sma <- polynomial(c(1, seasonal_poly))
    }
    else {
        sma <- 1
    }

    # pie
    n <- tol
    theta <- -c(coef(ma * sma))[-1]
    if (length(theta) == 0L) {
        theta <- 0
    }
    phi <- -c(coef(ar * sar)[-1], numeric(n))
    q <- length(theta)
    pie <- c(numeric(q), 1, numeric(n))
    for (j in seq(n)) {
        pie[j + q + 1L] <- -phi[j] + sum(theta * pie[(q:1L) + j])
    }
    pie <- pie[(0L:n) + q + 1L]
    pie <- head(pie, (tol+1)) 
    pie <- -pie[-1]

    c0 <- mu * (1 - sum(pie)) + dft * (t(seq_len(tol)) %*% pie)
    c1 <- dft * (1 - sum(pie))

    # y_t = c0 + c1 * t + pie_1 * y_{t-1} + ... + pie_tol * y_{t-tol} + epsilon_t
    coef <- `names<-` (
        c(c0, c1, pie), 
        c("beta0", "beta1", paste("ar", sep = "", seq_len(tol)))
    )

    return(coef)
}

auto_arima <- function(train_data, apply_dlsa, period = 1, tol = 500L,
                      order = c(0L, 0L, 0L), seasonal = c(0L, 0L, 0L),
                      max.p = 5, max.q = 5, max.P = 2, max.Q = 2,
                      max.order = 5, max.d = 2, max.D = 1,
                      allowmean = TRUE, allowdrift = TRUE, method = NULL,
                      approximation = (length(train_data) > 150 | period > 12),
                      stepwise = TRUE, parallel = FALSE, num.cores = 2){

    # Via auto.model(train_data) getting needed parameters:

    # d, D, m, mu, dft, phi, theta, Phi, Theta via auto.arima
    # Via UDF ar_coefficients() it will calculate the coefficients.
    # ar_coef, beta_coef and sigma_coef
    # Returning ar.coef as a Vector with named values.

    # train_data should be convert_to_r_time_series() is the original R function ts() converted to python
    # Is a TimeSeries object
    # Will find best parameters for the Darima model

      # sarima model
    if (sum(order) == 0L & sum(seasonal) == 0L){
    # no pre-defined order and seasonal order
        arima_model <- forecast::auto.arima(x=train_data, allowdrift = allowdrift, allowmean = allowmean,
                                    max.p = max.p, max.q = max.q, max.P = max.P, max.Q = max.Q,
                                    max.order = max.order, max.d = max.d, max.D = max.D,
                                    method = method, stepwise = stepwise,
                                    approximation = approximation,
                                    parallel = parallel, num.cores = num.cores)
    } else {
        arima_model <- forecast::Arima(train_data, order = order, seasonal = seasonal, method = method,
                               include.mean = allowmean, include.drift = allowdrift)
    }

    tol <- 2000

    # Fitting Arima Model
    # arima_model <- auto.arima(train_data)

    # Getting values from arima_model
    sigma2 <- c(arima_model$sigma2)

    d <- arima_model$arma[6]
    D <- arima_model$arma[7]
    m <- arima_model$arma[5]
    mu <- arima_model$coef[names(arima_model$coef) == "intercept"]
    if (length(mu)==0) {
        mu <- 0
    }
    dft <- arima_model$coef[names(arima_model$coef) == "drift"]
    if (length(dft)==0) {
        dft <- 0
    }
    phi <- arima_model$coef[substring(names(arima_model$coef), 1, 2) == "ar"]
    theta <- arima_model$coef[substring(names(arima_model$coef), 1, 2) == "ma"]
    Phi <- arima_model$coef[substring(names(arima_model$coef), 1, 3) == "sar"]
    Theta <- arima_model$coef[substring(names(arima_model$coef), 1, 3) == "sma"]

    # Calculating Coefficients
    ar.coef <- ar_coefficients(
        ar = phi, d = d, ma = theta, 
        sar = Phi, D = D, sma = Theta, 
        mean = mu, drift = dft, 
        m = m, tol = tol
    )
    if (apply_dlsa) {
        # Calculate Sig_inv and Sig_invMcoef
        #--------------------------------------
        sigma_normalized <- length(train_data)/sigma2
        ar.coef <- ar.coef * sigma_normalized
        ar.coef["sigma2"] <- sigma_normalized
        rm(sigma_normalized)
        print(length(train_data))
        print(ar.coef["sigma2"])
    } else {
        # append sigma to the resulting vector
        ar.coef["sigma2"] <- sigma2
    }

    # should be named vector
    return(ar.coef)
}



forecast_arima <- function(arima_model, test_data){

    # Prognose fÃ¼r die Testdaten
    forecast_values <- forecast(arima_model, h = length(test_data))

    write.csv(forecast_values, file = "forecasted_values.csv", row.names = FALSE)
    return (forecast_values)

}

# results <- auto_arima(train_data)